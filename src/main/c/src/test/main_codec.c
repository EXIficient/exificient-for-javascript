/*
 * Copyright (C) 2007-2016 Siemens AG
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
 * associated documentation files (the "Software"), to deal in the Software without restriction, 
 * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all copies or 
 * substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR 
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*******************************************************************
 *
 * @author Daniel.Peintner.EXT@siemens.com
 * @version 2016-10-20 
 * @contact Joerg.Heuer@siemens.com
 *
 * <p>Code generated by EXIdizer</p>
 * <p>Schema: exi4js.xsd.</p>
 *
 *
 ********************************************************************/



/*******************************************************************
 *
 * <p>Sample program to illustrate how to read an EXI stream and
 *  directly write it again to an output</p>
 *
 *  <p>e.g., <executable> in.exi out.exi</p>
 ********************************************************************/

/* Avoid VS warning, put before your included header files */
/* warning C4996: ‘fopen’: This function or variable may be unsafe. Consider using fopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. */
#define _CRT_SECURE_NO_DEPRECATE

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>

#include "EXIConfig.h"
#include "EXIforJSEXIDecoder.h"
#include "StringNameTable.h"
#include "EXIforJSEXIEncoder.h"
#include "EXITypes.h"
#include "ByteStream.h"
#include "ErrorCodes.h"
#include "EXIforJSQNames.h"

#if MEMORY_ALLOCATION == DYNAMIC_ALLOCATION
#include "DynamicMemory.h"
#include "StringValueTable.h"
#endif /* DYNAMIC_ALLOCATION */

#if MEMORY_ALLOCATION == STATIC_ALLOCATION
#include "EXIOptions.h"
#endif /* STATIC_ALLOCATION */

/** EXI Debug mode */
#define EXI_DEBUG 1


#if EXI_STREAM == BYTE_ARRAY
/* 64 kilobytes = 65 536 bytes */
/* 1 megabyte = 1 048 576 bytes*/
/* 4 megabytes = 4 194 304 bytes */
#define BUFFER_SIZE 200000
uint8_t bufferIn[BUFFER_SIZE];
uint8_t bufferOut[BUFFER_SIZE];
#endif /* EXI_STREAM == BYTE_ARRAY */

#if MEMORY_ALLOCATION == STATIC_ALLOCATION
/* avoids warning: initializer element is not computable at load time */
#define ARRAY_SIZE_BYTES 300
uint8_t bytesData[ARRAY_SIZE_BYTES];
#define ARRAY_SIZE_STRINGS 30000
exi_string_character_t characters[ARRAY_SIZE_STRINGS];
#endif /* STATIC_ALLOCATION */

/* String table memory setup */
uint16_t numberOfLocalStringsDecode[EXI_EXIforJSMAX_NUMBER_OF_QNAMES];
uint16_t numberOfLocalStringsEncode[EXI_EXIforJSMAX_NUMBER_OF_QNAMES];

#if EXI_DEBUG == 1
# define DEBUG_PRINTF(x) printf x
#else
# define DEBUG_PRINTF(x) do {} while (0)
#endif

static void debugValue(exi_value_t* val, exi_value_string_table_t* valueTable, size_t namespaceUriID, size_t localNameID);

int main(int argc, char *argv[]) {

	int errn = 0;
	int noEndOfDocument;

	unsigned int k;

	bitstream_t iStream, oStream;
#if EXI_STREAM == BYTE_ARRAY
	size_t posDecode;
	size_t posEncode;
#endif /* EXI_STREAM == BYTE_ARRAY */

	/* EXI set-up */
	exi_state_t stateDecode;
	exi_state_t stateEncode;
	exi_event_t event;
	/*uint16_t qnameID = 0;*/ /* qname */
	size_t namespaceUriID = 0; /* qname */
	size_t localNameID = 0; /* qname */
	/* uint16_t lastKnownQNameID = EXI_EXIforJSNUMBER_OF_PREPOPULATED_QNAMES - 1; */
	exi_qname_t* qname;
	exi_value_t val;

	exi_name_table_runtime_t runtimeTableDecode;
	exi_name_table_runtime_t runtimeTableEncode;

#if MEMORY_ALLOCATION == STATIC_ALLOCATION
#if EXI_OPTION_VALUE_PARTITION_CAPACITY > 0
#if EXI_OPTION_VALUE_MAX_LENGTH > 0
    static exi_value_string_table_entry_t encodeEntries[EXI_OPTION_VALUE_PARTITION_CAPACITY];
    static exi_string_t encodeStrings[EXI_OPTION_VALUE_PARTITION_CAPACITY];
    static exi_string_character_t encodeStringChars[EXI_OPTION_VALUE_PARTITION_CAPACITY][EXI_OPTION_VALUE_MAX_LENGTH];

    static exi_value_string_table_entry_t decodeEntries[EXI_OPTION_VALUE_PARTITION_CAPACITY];
    static exi_string_t decodeStrings[EXI_OPTION_VALUE_PARTITION_CAPACITY];
    static exi_string_character_t decodeStringChars[EXI_OPTION_VALUE_PARTITION_CAPACITY][EXI_OPTION_VALUE_MAX_LENGTH];
#endif /* EXI_OPTION_VALUE_MAX_LENGTH > 0 */
#endif /* EXI_OPTION_VALUE_PARTITION_CAPACITY > 0 */
#endif /* STATIC_ALLOCATION */

	/*exi_value_table_t stringTableDecode = { 0, EXI_EXIforJSMAX_NUMBER_OF_QNAMES, numberOfLocalStringsDecode, NULL };
	exi_value_table_t stringTableEncode = { 0, EXI_EXIforJSMAX_NUMBER_OF_QNAMES, numberOfLocalStringsEncode, NULL };*/
    exi_value_string_table_t stringTableDecode = { 0, NULL, 0 };
    exi_value_string_table_t stringTableEncode = { 0, NULL, 0 };

/* #if MEMORY_ALLOCATION == DYNAMIC_ALLOCATION */
	exi_value_string_table_t stringTableValuesDecode;
	exi_value_string_table_t stringTableValuesEncode;

	stringTableValuesDecode.size = 0;
	stringTableValuesDecode.len = 0;
	stringTableValuesEncode.size = 0;
	stringTableValuesEncode.len = 0;

#if MEMORY_ALLOCATION == STATIC_ALLOCATION
#if EXI_OPTION_VALUE_PARTITION_CAPACITY > 0
#if EXI_OPTION_VALUE_MAX_LENGTH > 0
       stringTableValuesEncode.size = EXI_OPTION_VALUE_PARTITION_CAPACITY;
       stringTableValuesEncode.strs = encodeEntries;

       for (k = 0; k < stringTableValuesEncode.size; k++) {
             stringTableValuesEncode.strs[k].str = encodeStrings[k];
             stringTableValuesEncode.strs[k].str.len = 0;
             stringTableValuesEncode.strs[k].str.characters = &(encodeStringChars[k][0]);
             stringTableValuesEncode.strs[k].str.size = sizeof(encodeStringChars[k]);
       }

       stringTableValuesDecode.size = EXI_OPTION_VALUE_PARTITION_CAPACITY;
       stringTableValuesDecode.strs = decodeEntries;

       for (k = 0; k < stringTableValuesDecode.size; k++) {
             stringTableValuesDecode.strs[k].str = decodeStrings[k];
             stringTableValuesDecode.strs[k].str.len = 0;
             stringTableValuesDecode.strs[k].str.characters = &(decodeStringChars[k][0]);
             stringTableValuesDecode.strs[k].str.size = sizeof(decodeStringChars[k]);
       }
#endif /* EXI_OPTION_VALUE_MAX_LENGTH > 0 */
#endif /* EXI_OPTION_VALUE_PARTITION_CAPACITY > 0 */
#endif /* STATIC_ALLOCATION */

	/** string values */
	/* stringTableDecode.valueStringTable = &stringTableValuesDecode;
	stringTableEncode.valueStringTable = &stringTableValuesEncode;*/
/* #endif */ /* DYNAMIC_ALLOCATION */


	/* BINARY memory setup */
	val.binary.len = 0;
#if MEMORY_ALLOCATION == STATIC_ALLOCATION
	val.binary.size = ARRAY_SIZE_BYTES;
	val.binary.data = bytesData;
#endif /* STATIC_ALLOCATION */
#if MEMORY_ALLOCATION == DYNAMIC_ALLOCATION
	val.binary.size = 0;
	val.binary.data = NULL;
#endif /* DYNAMIC_ALLOCATION */

	/* STRING miss memory setup */
	val.str.type = EXI_STRING_VALUE_MISS;
	val.str.miss.len = 0;
#if MEMORY_ALLOCATION == STATIC_ALLOCATION
	val.str.miss.size = ARRAY_SIZE_STRINGS;
	val.str.miss.characters = characters;
#endif /* STATIC_ALLOCATION */
#if MEMORY_ALLOCATION == DYNAMIC_ALLOCATION
	val.str.miss.size = 0;
	val.str.miss.characters = NULL;
#endif /* DYNAMIC_ALLOCATION */

#if EXI_DEBUG == 1
	/* The Eclipse console has buffering problems on Windows e.g, Debug mode */
	setvbuf(stdout, NULL, _IONBF, 0);
	setvbuf(stderr, NULL, _IONBF, 0);
#endif /*EXI_DEBUG*/

	if (argc != 3) {
		printf("Usage: %s exiInput exiOutput\n", argv[0]);
		return -1;
	}


#if EXI_STREAM == BYTE_ARRAY
	/* input pos */
	posDecode = 0;
	/* parse EXI stream to internal byte structures  */
	errn = readBytesFromFile(argv[1], bufferIn, BUFFER_SIZE, &posDecode);
	if (errn != 0) {
		printf("Problems while reading file into buffer\n");
		return errn;
	}
	posDecode = 0; /* reset position */
#endif /* EXI_STREAM == BYTE_ARRAY */

	/* setup input stream */
#if EXI_STREAM == BYTE_ARRAY
	iStream.size = BUFFER_SIZE;
	iStream.data = bufferIn;
	iStream.pos = &posDecode;
#endif /* EXI_STREAM == BYTE_ARRAY */
#if EXI_STREAM == FILE_STREAM
	iStream.file = fopen(argv[1], "rb");
#endif /* EXI_STREAM == FILE_STREAM */


#if EXI_STREAM == BYTE_ARRAY
	/* setup output stream */
	posEncode = 0;
	oStream.size = BUFFER_SIZE;
	oStream.data = bufferOut;
	oStream.pos = &posEncode;
#endif
#if EXI_STREAM == FILE_STREAM
	oStream.file = fopen(argv[2], "wb");
#endif /* EXI_STREAM == FILE_STREAM */

	noEndOfDocument = 1; /* true */

	/* init decoder (read header, set initial state) */
	/* init runtime table */
	errn = exiInitNameTableRuntime(&runtimeTableDecode);
	if (errn==0) {
		errn = exiEXIforJSInitDecoder(&iStream, &stateDecode, &runtimeTableDecode, &stringTableDecode);
	}
	if (errn) {
		DEBUG_PRINTF(("[Init-Decode-ERROR] %d \n", errn));
		return errn;
	}

	/* init encoder (write header, set initial state) */
	errn = exiInitNameTableRuntime(&runtimeTableEncode);
	if (errn==0) {
		errn = exiEXIforJSInitEncoder(&oStream, &stateEncode, &runtimeTableEncode, &stringTableEncode);
	}
	if (errn) {
		DEBUG_PRINTF(("[Init-Encode-ERROR] %d \n", errn));
		return errn;
	}

	DEBUG_PRINTF(("[DECODE] >>> EXI  >>> [ENCODE] \n"));

	do {
		if (errn) {
			DEBUG_PRINTF(("[Encode-ERROR] %d \n", errn));
			return errn;
		}

		errn = exiEXIforJSDecodeNextEvent(&iStream, &stateDecode,
				&event);
		if (errn) {
			DEBUG_PRINTF(("[Decode-ERROR] %d \n", errn));
			return errn;
		}

		switch (event) {
		case EXI_EVENT_START_DOCUMENT:
			/* decode */
			errn = exiEXIforJSDecodeStartDocument(&iStream,
					&stateDecode);
			if (errn) {
				DEBUG_PRINTF(("[Decode-ERROR-SD] %d \n", errn));
				return errn;
			}
			DEBUG_PRINTF((">> START_DOCUMENT \n"));
			/* encode */
			errn = exiEXIforJSEncodeStartDocument(&oStream,
					&stateEncode);
			break;
		case EXI_EVENT_END_DOCUMENT:
			/* decode */
			errn = exiEXIforJSDecodeEndDocument(&iStream,
					&stateDecode);
			if (errn) {
				DEBUG_PRINTF(("[Decode-ERROR-ED] %d \n", errn));
				return errn;
			}
			DEBUG_PRINTF((">> END_DOCUMENT \n"));
			/* encode */
			errn = exiEXIforJSEncodeEndDocument(&oStream,
					&stateEncode);
			/* signalize end of document */
			noEndOfDocument = 0; /* false */
			break;
		case EXI_EVENT_START_ELEMENT:
		case EXI_EVENT_START_ELEMENT_GENERIC:
		case EXI_EVENT_START_ELEMENT_GENERIC_UNDECLARED:
			/* decode */
			errn = exiEXIforJSDecodeStartElement(&iStream,
					&stateDecode, &namespaceUriID, &localNameID);
			if (errn) {
				DEBUG_PRINTF(("[Decode-ERROR-SE] %d \n", errn));
				return errn;
			}
			DEBUG_PRINTF((">> SE ({%d}%d) \n", namespaceUriID, localNameID));
			/* encode */
			if(stateDecode.nextQNameID > stateEncode.nextQNameID) {
				/* new qname */
				/* lastKnownQNameID = qnameID;*/
				/* URI or LocalName known ? */
				errn = exiEXIforJSGetLastQName(&qname);
				if(qname->uri.type == EXI_NAME_ENTRY_TYPE_ID) {
					/* local name only new */
					errn = exiEXIforJSEncodeStartElementNS(&oStream,
							&stateEncode, qname->uri.id, &qname->localName.str);
				} else {
					/* both, uri and localname new */
					errn = exiEXIforJSEncodeStartElementGeneric(&oStream,
							&stateEncode, &qname->uri.str, &qname->localName.str);
				}
			} else {
				errn = exiEXIforJSEncodeStartElement(&oStream,
						&stateEncode, namespaceUriID, localNameID);
			}
			break;
		case EXI_EVENT_END_ELEMENT:
		case EXI_EVENT_END_ELEMENT_UNDECLARED:
			/* decode */
			errn = exiEXIforJSDecodeEndElement(&iStream,
					&stateDecode, &namespaceUriID, &localNameID );
			if (errn) {
				DEBUG_PRINTF(("[Decode-ERROR-EE] %d \n", errn));
				return errn;
			}
			DEBUG_PRINTF(("<< EE \n"));
			/* encode */
			errn = exiEXIforJSEncodeEndElement(&oStream,
							&stateEncode);
			break;
		case EXI_EVENT_CHARACTERS:
		case EXI_EVENT_CHARACTERS_GENERIC:
		case EXI_EVENT_CHARACTERS_GENERIC_UNDECLARED:
			/* decode */
			errn = exiEXIforJSDecodeCharacters(&iStream,
					&stateDecode, &val);
			if (errn) {
				DEBUG_PRINTF(("[Decode-ERROR-CH] %d \n", errn));
				return errn;
			}
			DEBUG_PRINTF((" CH: "));
			debugValue(&val, &stringTableDecode, stateDecode.elementStack[stateDecode.stackIndex].namespaceURI, stateDecode.elementStack[stateDecode.stackIndex].localPart);
			/* encode */
			errn = exiEXIforJSEncodeCharacters(&oStream,
						&stateEncode, &val);

			/* list value: special behavior */
			if (val.type == EXI_DATATYPE_LIST) {
				for(k=0; k<val.list.len; k++) {
					errn = exiEXIforJSDecodeListValue(&iStream, &stateDecode, namespaceUriID, localNameID, &val, val.list);
					if (errn) {
						DEBUG_PRINTF(("[Decode-ERROR-CH_LIST] %d \n", errn));
						return errn;
					}
					DEBUG_PRINTF((" CH: "));
					debugValue(&val, &stringTableDecode, stateDecode.elementStack[stateDecode.stackIndex].namespaceURI, stateDecode.elementStack[stateDecode.stackIndex].localPart);
					/* encode list value */
					errn = exiEXIforJSEncodeListValue(&oStream, &stateEncode, namespaceUriID, localNameID,
									&val, val.list);
				}
			}
			break;
		case EXI_EVENT_ATTRIBUTE:
		case EXI_EVENT_ATTRIBUTE_GENERIC:
		case EXI_EVENT_ATTRIBUTE_GENERIC_UNDECLARED:
		case EXI_EVENT_ATTRIBUTE_INVALID_VALUE:
			/* decode */
			errn = exiEXIforJSDecodeAttribute(&iStream, &stateDecode,
					&namespaceUriID, &localNameID, &val);
			if (errn) {
				DEBUG_PRINTF(("[Decode-ERROR-AT] %d \n", errn));
				return errn;
			}
			DEBUG_PRINTF((" AT ({%d}%d): ", namespaceUriID, localNameID));
			debugValue(&val, &stringTableDecode, namespaceUriID, localNameID);
			/* encode */
			if(stateDecode.nextQNameID > stateEncode.nextQNameID) {
				/* new qname */
				/* lastKnownQNameID = qnameID; */
				/* URI or LocalName known ? */
				errn = exiEXIforJSGetLastQName(&qname);
				if(qname->uri.type == EXI_NAME_ENTRY_TYPE_ID) {
					/* local name only new */
					errn = exiEXIforJSEncodeAttributeNS(&oStream,
							&stateEncode, qname->uri.id, &qname->localName.str, &val);
				} else {
					/* both, uri and localname new */
					errn = exiEXIforJSEncodeAttributeGeneric(&oStream,
							&stateEncode, &qname->uri.str, &qname->localName.str, &val);
				}
			} else {
				errn = exiEXIforJSEncodeAttribute(&oStream, &stateEncode,
						namespaceUriID, localNameID, &val);
			}
			break;
		case EXI_EVENT_ATTRIBUTE_XSI_NIL:
			/* decode */
			errn = exiEXIforJSDecodeAttributeXsiNil(&iStream,
					&stateDecode, &val);
			if (errn) {
				DEBUG_PRINTF(("[Decode-ERROR-AT-NIL] %d \n", errn));
				return errn;
			}
			DEBUG_PRINTF((" AT {xsi}nil == %i \n", val.boolean));
			/* encode */
			errn = exiEXIforJSEncodeAttributeXsiNil(&oStream,
					&stateEncode, &val);
			break;
		case EXI_EVENT_ATTRIBUTE_XSI_TYPE:
			/* decode */
			errn = exiEXIforJSDecodeAttributeXsiType(&iStream,
					&stateDecode, &val);
			if (errn) {
				DEBUG_PRINTF(("[Decode-ERROR-AT-TYPE] %d \n", errn));
				return errn;
			}
			DEBUG_PRINTF((" AT {type}type == {%d}%d \n", val.eqname.namespaceURI, val.eqname.localPart));
			/* encode */
			errn = exiEXIforJSEncodeAttributeXsiType(&oStream,
					&stateEncode, &val);
			break;
		default:
			/* ERROR */
			DEBUG_PRINTF(("[Unknown-Event] %d \n", event));
			return EXI_ERROR_UNKOWN_EVENT;
		}

	} while (noEndOfDocument);

#if EXI_STREAM == BYTE_ARRAY
	/* write to file */
	writeBytesToFile(oStream.data, posEncode, argv[2]);
#endif
#if EXI_STREAM == FILE_STREAM
	fclose(iStream.file);
	fclose(oStream.file);
#endif

#if MEMORY_ALLOCATION == DYNAMIC_ALLOCATION
	/* free memory if any */
	exiFreeDynamicStringMemory(&val.str.miss);
	exiFreeDynamicBinaryMemory(&val.binary);
#endif /* DYNAMIC_ALLOCATION */



	return errn;
}


#if EXI_DEBUG == 1
static void debugValueInteger(exi_integer_t* integer) {
	switch (integer->type) {
	/* Unsigned Integer */
	case EXI_UNSIGNED_INTEGER_8:
		printf("uint8 : %d \n", integer->val.uint8);
		break;
	case EXI_UNSIGNED_INTEGER_16:
		printf("uint16 : %d \n", integer->val.uint16);
		break;
	case EXI_UNSIGNED_INTEGER_32:
		printf("uint32 : %d \n", integer->val.uint32);
		break;
	case EXI_UNSIGNED_INTEGER_64:
		printf("uint64 : %ld \n",
				(long unsigned int) integer->val.uint64);
		break;
		/* (Signed) Integer */
	case EXI_INTEGER_8:
		printf("int8 : %d \n", integer->val.int8);
		break;
	case EXI_INTEGER_16:
		printf("int16 : %d \n", integer->val.int16);
		break;
	case EXI_INTEGER_32:
		printf("int32 : %d \n", integer->val.int32);
		break;
	case EXI_INTEGER_64:
		printf("int64 : %ld \n", (long int) integer->val.int64);
		break;
	}
}
#endif /* EXI_DEBUG == 1 */

static void debugValue(exi_value_t* val, exi_value_string_table_t* valueTable, size_t namespaceUriID, size_t localNameID) {
	exi_string_t sv;

#if EXI_DEBUG == 1
	int i;
	switch (val->type) {
	case EXI_DATATYPE_NBIT_UNSIGNED_INTEGER:
	case EXI_DATATYPE_UNSIGNED_INTEGER:
	case EXI_DATATYPE_INTEGER:
		debugValueInteger(&(val->integer));
		break;
	case EXI_DATATYPE_BINARY_BASE64:
	case EXI_DATATYPE_BINARY_HEX:
		printf("Binary (len == %d) : ", val->binary.len);
		for (i = 0; i < val->binary.len; i++) {
			printf(" [%d]", val->binary.data[i]);
		}
		printf("\n");
		break;
	case EXI_DATATYPE_BOOLEAN:
		printf("Boolean : %d \n", val->boolean);
		break;
	case EXI_DATATYPE_DECIMAL:
		/* Note: reversed fractional part */
		printf("Decimal : negative: %d followed by integral and reversed fractional part \n", val->decimal.negative);
		debugValueInteger(&(val->decimal.integral));
		debugValueInteger(&(val->decimal.reverseFraction));
		break;
	case EXI_DATATYPE_FLOAT:
		if(val->float_me.exponent == FLOAT_EXPONENT_SPECIAL_VALUES) {
			if (val->float_me.mantissa == FLOAT_MANTISSA_INFINITY) {
				printf("Float Special: INF \n");
			} else if (val->float_me.mantissa == FLOAT_MANTISSA_MINUS_INFINITY) {
				printf("Float Special: -INF \n");
			} else {
				printf("Float Special: NaN \n");
			}
		} else {
			printf("Float : %ld E %d \n", (long int) val->float_me.mantissa, val->float_me.exponent);
		}
		break;
	case EXI_DATATYPE_STRING:
	case EXI_DATATYPE_RCS_STRING:
		switch(val->str.type) {
		case EXI_STRING_VALUE_MISS:
			printf("String Miss (len==%d) : '", val->str.miss.len);
			for (i = 0; i < val->str.miss.len; i++) {
				printf("%c", (char) val->str.miss.characters[i]);
			}
			printf("'\n");
			break;
		case EXI_STRING_VALUE_LOCAL_HIT:
			printf("String LocalHit: %d", val->str.localID);
/*#if MEMORY_ALLOCATION == DYNAMIC_ALLOCATION*/
			if( exiGetLocalStringValue(valueTable, namespaceUriID, localNameID, (uint16_t)(val->str.localID), &sv)) {
				printf("ERROR when retrieving localvalue hit \n");
			} else {
				printf(" --> '");
				for (i = 0; i < sv.len; i++) {
					printf("%c", (char) sv.characters[i]);
				}
				printf("'");
			}
/*#endif*/ /* DYNAMIC_ALLOCATION */
			printf("\n");
			break;
		case EXI_STRING_VALUE_GLOBAL_HIT:
			printf("String GlobalHit: %d ", val->str.globalID);
/*#if MEMORY_ALLOCATION == DYNAMIC_ALLOCATION*/
			if( exiGetGlobalStringValue(valueTable, (uint16_t)(val->str.globalID), &sv)) {
				printf("ERROR when retrieving global value hit \n");
			} else {
				printf(" --> '");
				for (i = 0; i < sv.len; i++) {
					printf("%c", (char) sv.characters[i]);
				}
				printf("'");
			}
/*#endif*/ /* DYNAMIC_ALLOCATION */
			printf("\n");
			break;
		}
		break;
	case EXI_DATATYPE_DATETIME:
		switch(val->datetime.type) {
		case EXI_DATETIME_GYEAR:
			printf("Datetime gYear: %d", val->datetime.year);
			break;
		case EXI_DATETIME_GYEARMONTH:
			printf("Datetime gYearMonth: Year=%d, MonthDay=%d", val->datetime.year, val->datetime.monthDay);
			break;
		case EXI_DATETIME_DATE:
			printf("Datetime date: Year=%d, MonthDay=%d", val->datetime.year, val->datetime.monthDay);
			break;
		case EXI_DATETIME_DATETIME:
			printf("Datetime dateTime: Year=%d, MonthDay=%d, Time=%d", val->datetime.year, val->datetime.monthDay, val->datetime.time);
			break;
		case EXI_DATETIME_GMONTH:
			printf("Datetime gMonth: MonthDay=%d", val->datetime.monthDay);
			break;
		case EXI_DATETIME_GMONTHDAY:
			printf("Datetime gMonthDay: MonthDay=%d", val->datetime.monthDay);
			break;
		case EXI_DATETIME_GDAY:
			printf("Datetime gDay: MonthDay=%d", val->datetime.monthDay);
			break;
		case EXI_DATETIME_TIME:
			printf("Datetime time: Time=%d", val->datetime.time);
			break;
		default:
			printf("Datetime ?Type?");
			break;
		}
		if(val->datetime.presenceFractionalSecs) {
			printf(", FractionalSecs=%d", val->datetime.fractionalSecs);
		}
		if(val->datetime.presenceTimezone) {
			printf(", TimeZone=%d", val->datetime.timezone);
		}
		printf("\n");
		break;
	case EXI_DATATYPE_ENUMERATION:
		printf("Enumeration (id==%d) \n", val->enumeration);
		break;
	case EXI_DATATYPE_LIST:
		printf("List (len==%d) \n", val->list.len);
		break;
	case EXI_DATATYPE_QNAME:
		printf("QName (uri==%d, localName=%d) \n", val->eqname.namespaceURI, val->eqname.localPart);
		break;
	default:
		printf(" ?Value-Type? \n");
		break;
	}
#endif /*EXI_DEBUG*/
}

