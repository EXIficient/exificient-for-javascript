/*
 * Copyright (C) 2007-2016 Siemens AG
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
 * associated documentation files (the "Software"), to deal in the Software without restriction, 
 * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all copies or 
 * substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR 
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*******************************************************************
 *
 * @author Daniel.Peintner.EXT@siemens.com
 * @version 2016-10-20 
 * @contact Joerg.Heuer@siemens.com
 *
 * <p>Code generated by EXIdizer</p>
 * <p>Schema: exi4js.xsd.</p>
 *
 *
 ********************************************************************/



#ifndef EXI_EXIforJS_QNAMES_C
#define EXI_EXIforJS_QNAMES_C

#include "EXITypes.h"
#include "ErrorCodes.h"
#include "EXIforJSQNames.h"

/* qname is a composition of namespaceURI(ID) and localPart(ID) */
static exi_eqname_t qnames[EXI_EXIforJSMAX_NUMBER_OF_QNAMES] = {
	/* {1}0,base */
	{1, 0},
	/* {1}1,id */
	{1, 1},
	/* {1}2,lang */
	{1, 2},
	/* {1}3,space */
	{1, 3},
	/* {2}0,nil */
	{2, 0},
	/* {2}1,type */
	{2, 1},
	/* {3}0,ENTITIES */
	{3, 0},
	/* {3}1,ENTITY */
	{3, 1},
	/* {3}2,ID */
	{3, 2},
	/* {3}3,IDREF */
	{3, 3},
	/* {3}4,IDREFS */
	{3, 4},
	/* {3}5,NCName */
	{3, 5},
	/* {3}6,NMTOKEN */
	{3, 6},
	/* {3}7,NMTOKENS */
	{3, 7},
	/* {3}8,NOTATION */
	{3, 8},
	/* {3}9,Name */
	{3, 9},
	/* {3}10,QName */
	{3, 10},
	/* {3}11,anySimpleType */
	{3, 11},
	/* {3}12,anyType */
	{3, 12},
	/* {3}13,anyURI */
	{3, 13},
	/* {3}14,base64Binary */
	{3, 14},
	/* {3}15,boolean */
	{3, 15},
	/* {3}16,byte */
	{3, 16},
	/* {3}17,date */
	{3, 17},
	/* {3}18,dateTime */
	{3, 18},
	/* {3}19,decimal */
	{3, 19},
	/* {3}20,double */
	{3, 20},
	/* {3}21,duration */
	{3, 21},
	/* {3}22,float */
	{3, 22},
	/* {3}23,gDay */
	{3, 23},
	/* {3}24,gMonth */
	{3, 24},
	/* {3}25,gMonthDay */
	{3, 25},
	/* {3}26,gYear */
	{3, 26},
	/* {3}27,gYearMonth */
	{3, 27},
	/* {3}28,hexBinary */
	{3, 28},
	/* {3}29,int */
	{3, 29},
	/* {3}30,integer */
	{3, 30},
	/* {3}31,language */
	{3, 31},
	/* {3}32,long */
	{3, 32},
	/* {3}33,negativeInteger */
	{3, 33},
	/* {3}34,nonNegativeInteger */
	{3, 34},
	/* {3}35,nonPositiveInteger */
	{3, 35},
	/* {3}36,normalizedString */
	{3, 36},
	/* {3}37,positiveInteger */
	{3, 37},
	/* {3}38,short */
	{3, 38},
	/* {3}39,string */
	{3, 39},
	/* {3}40,time */
	{3, 40},
	/* {3}41,token */
	{3, 41},
	/* {3}42,unsignedByte */
	{3, 42},
	/* {3}43,unsignedInt */
	{3, 43},
	/* {3}44,unsignedLong */
	{3, 44},
	/* {3}45,unsignedShort */
	{3, 45},
	/* {4}0,ArrayExpression */
	{4, 0},
	/* {4}1,ArrayPattern */
	{4, 1},
	/* {4}2,ArrowExpression */
	{4, 2},
	/* {4}3,AssignmentExpression */
	{4, 3},
	/* {4}4,BinaryExpression */
	{4, 4},
	/* {4}5,BlockStatement */
	{4, 5},
	/* {4}6,BreakStatement */
	{4, 6},
	/* {4}7,CallExpression */
	{4, 7},
	/* {4}8,CatchClause */
	{4, 8},
	/* {4}9,ComprehensionExpression */
	{4, 9},
	/* {4}10,ConditionalExpression */
	{4, 10},
	/* {4}11,ContinueStatement */
	{4, 11},
	/* {4}12,DebuggerStatement */
	{4, 12},
	/* {4}13,Declaration */
	{4, 13},
	/* {4}14,DoWhileStatement */
	{4, 14},
	/* {4}15,EmptyStatement */
	{4, 15},
	/* {4}16,Expression */
	{4, 16},
	/* {4}17,ExpressionStatement */
	{4, 17},
	/* {4}18,ForInStatement */
	{4, 18},
	/* {4}19,ForOfStatement */
	{4, 19},
	/* {4}20,ForStatement */
	{4, 20},
	/* {4}21,FunctionDeclaration */
	{4, 21},
	/* {4}22,FunctionExpression */
	{4, 22},
	/* {4}23,GeneratorExpression */
	{4, 23},
	/* {4}24,GraphExpression */
	{4, 24},
	/* {4}25,GraphIndexExpression */
	{4, 25},
	/* {4}26,Identifier */
	{4, 26},
	/* {4}27,IfStatement */
	{4, 27},
	/* {4}28,LabeledStatement */
	{4, 28},
	/* {4}29,LetExpression */
	{4, 29},
	/* {4}30,LetStatement */
	{4, 30},
	/* {4}31,Literal */
	{4, 31},
	/* {4}32,LogicalExpression */
	{4, 32},
	/* {4}33,MemberExpression */
	{4, 33},
	/* {4}34,NewExpression */
	{4, 34},
	/* {4}35,ObjectExpression */
	{4, 35},
	/* {4}36,ObjectPattern */
	{4, 36},
	/* {4}37,Pattern */
	{4, 37},
	/* {4}38,Program */
	{4, 38},
	/* {4}39,Property */
	{4, 39},
	/* {4}40,RegExp */
	{4, 40},
	/* {4}41,ReturnStatement */
	{4, 41},
	/* {4}42,SequenceExpression */
	{4, 42},
	/* {4}43,Statement */
	{4, 43},
	/* {4}44,SwitchCase */
	{4, 44},
	/* {4}45,SwitchStatement */
	{4, 45},
	/* {4}46,ThisExpression */
	{4, 46},
	/* {4}47,ThrowStatement */
	{4, 47},
	/* {4}48,TryStatement */
	{4, 48},
	/* {4}49,UnaryExpression */
	{4, 49},
	/* {4}50,UpdateExpression */
	{4, 50},
	/* {4}51,VariableDeclaration */
	{4, 51},
	/* {4}52,VariableDeclarator */
	{4, 52},
	/* {4}53,WhileStatement */
	{4, 53},
	/* {4}54,WithStatement */
	{4, 54},
	/* {4}55,YieldExpression */
	{4, 55},
	/* {4}56,alternate */
	{4, 56},
	/* {4}57,argument */
	{4, 57},
	/* {4}58,arguments */
	{4, 58},
	/* {4}59,array */
	{4, 59},
	/* {4}60,block */
	{4, 60},
	/* {4}61,body */
	{4, 61},
	/* {4}62,boolean */
	{4, 62},
	/* {4}63,callee */
	{4, 63},
	/* {4}64,cases */
	{4, 64},
	/* {4}65,computed */
	{4, 65},
	/* {4}66,consequent */
	{4, 66},
	/* {4}67,declarations */
	{4, 67},
	/* {4}68,defaults */
	{4, 68},
	/* {4}69,discriminant */
	{4, 69},
	/* {4}70,each */
	{4, 70},
	/* {4}71,elements */
	{4, 71},
	/* {4}72,expression */
	{4, 72},
	/* {4}73,finalizer */
	{4, 73},
	/* {4}74,generator */
	{4, 74},
	/* {4}75,guard */
	{4, 75},
	/* {4}76,guardedHandlers */
	{4, 76},
	/* {4}77,handler */
	{4, 77},
	/* {4}78,id */
	{4, 78},
	/* {4}79,init */
	{4, 79},
	/* {4}80,integer */
	{4, 80},
	/* {4}81,key */
	{4, 81},
	/* {4}82,kind */
	{4, 82},
	/* {4}83,label */
	{4, 83},
	/* {4}84,left */
	{4, 84},
	/* {4}85,lexical */
	{4, 85},
	/* {4}86,name */
	{4, 86},
	/* {4}87,null */
	{4, 87},
	/* {4}88,number */
	{4, 88},
	/* {4}89,object */
	{4, 89},
	/* {4}90,operator */
	{4, 90},
	/* {4}91,param */
	{4, 91},
	/* {4}92,params */
	{4, 92},
	/* {4}93,prefix */
	{4, 93},
	/* {4}94,properties */
	{4, 94},
	/* {4}95,property */
	{4, 95},
	/* {4}96,rest */
	{4, 96},
	/* {4}97,right */
	{4, 97},
	/* {4}98,string */
	{4, 98},
	/* {4}99,test */
	{4, 99},
	/* {4}100,update */
	{4, 100},
	/* {4}101,value */
	{4, 101}

};


/* int exiEXIforJSGetEQName(exi_state_t* state, uint16_t namespaceUriID, uint16_t localNameID, uint16_t* namespaceURI, uint16_t* localPart) {
	int errn = 0;
	/ * EXI_EXIforJSNUMBER_OF_QNAMES * /
	if (qnameID < state->nextQNameID) {
		*namespaceURI = qnames[qnameID].namespaceURI;
		*localPart = qnames[qnameID].localPart;
	} else {
		errn = EXI_ERROR_OUT_OF_BOUNDS;
	}
	return errn;
}
*/


/* int exiEXIforJSGetQNameIDs(exi_state_t* state, uint16_t namespaceURI, uint16_t localPart, uint16_t* namespaceUriID, uint16_t* localNameID) {
	uint16_t i;
	int errn = EXI_ERROR_OUT_OF_BOUNDS;
	/ * TODO Do something more efficient than just walk over the entire list * /
	/ * EXI_EXIforJSNUMBER_OF_QNAMES * /
	for(i=0; i<state->nextQNameID && errn != 0; i++) {
		if(qnames[i].localPart == localPart && qnames[i].namespaceURI == namespaceURI) {
			/ * *qnameID = i; * /
			printf("error GetQNameIDs \n");
			*namespaceUriID = -1;
			*localNameID = -1;
			errn = 0;
		}
	}

	return errn;
}
*/


int exiEXIforJSAddEQName(exi_state_t* state,
		/* uint16_t* qnameID,  */
		size_t namespaceUriID, size_t localNameID) {
	int errn = 0;
	if(state->nextQNameID < (EXI_EXIforJSMAX_NUMBER_OF_QNAMES -1)) {
		/* store IDs */
		qnames[state->nextQNameID].namespaceURI = namespaceUriID;
		qnames[state->nextQNameID].localPart = localNameID;
		/* increment counter */
		state->nextQNameID++;
		/* *qnameID = state->nextQNameID++; */
	} else {
		errn = EXI_ERROR_OUT_OF_BOUNDS;
	}


	return errn;
}


#endif

