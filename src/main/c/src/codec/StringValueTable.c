/*
 * Copyright (C) 2007-2016 Siemens AG
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
 * associated documentation files (the "Software"), to deal in the Software without restriction, 
 * including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all copies or 
 * substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR 
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/*******************************************************************
 *
 * @author Daniel.Peintner.EXT@siemens.com
 * @version 2016-10-20 
 * @contact Joerg.Heuer@siemens.com
 *
 * <p>Code generated by EXIdizer</p>
 * <p>Schema: exi4js.xsd.</p>
 *
 *
 ********************************************************************/



#ifndef STRING_VALUE_TABLE_C
#define STRING_VALUE_TABLE_C

#include <string.h>

#include "StringValueTable.h"

#include "EXIConfig.h"
#include "ErrorCodes.h"
#include "EXIOptions.h"

#if MEMORY_ALLOCATION == DYNAMIC_ALLOCATION
#include "DynamicMemory.h"
#include <stdlib.h>
#endif /* DYNAMIC_ALLOCATION */

#define STRING_TABLE_INIT_VALUE_ENTRY_SIZE 16

int exiInitValueStrings(exi_value_string_table_t* valueTable) {
	/*int i;*/
	int errn = 0;

	/* valueTable->numberOfGlobalStrings = 0; */
#if EXI_OPTION_VALUE_PARTITION_CAPACITY != 0
#if EXI_OPTION_VALUE_MAX_LENGTH != 0
	/* for(i=0; i<(valueTable->sizeLocalStrings); i++) {
		valueTable->numberOfLocalStrings[i] = 0;
	}*/
#endif /* EXI_OPTION_VALUE_MAX_LENGTH != 0 */
#endif /* EXI_OPTION_VALUE_PARTITION_CAPACITY != 0 */
#if MEMORY_ALLOCATION == DYNAMIC_ALLOCATION
	valueTable->size = 0;
#endif /* DYNAMIC_ALLOCATION */
	valueTable->len = 0;

	return errn;
}


int exiAddStringValue(exi_value_string_table_t* valueTable, exi_string_t* sv, size_t namespaceUriID, size_t localNameID) {

	size_t currID;
	size_t numberOfEntries;
	int errn = 0;
	unsigned int extraChar = 0;
	exi_value_string_table_entry_t* oldStrs;
	size_t i;

	if(valueTable == 0) {
		/* indicates that no value is added */
		return EXI_ERROR_STRINGVALUES_OUT_OF_MEMORY;
	}

#if EXI_OPTION_VALUE_PARTITION_CAPACITY != 0
#if EXI_OPTION_VALUE_MAX_LENGTH != 0


	if (EXI_OPTION_VALUE_MAX_LENGTH > 0 &&  sv->len > EXI_OPTION_VALUE_MAX_LENGTH) {
		/* string to long */
		return errn;
	}
	/* if(EXI_OPTION_VALUE_PARTITION_CAPACITY > 0) {
		/ * round robin not supported * /
		errn = EXI_ERROR_STRINGVALUES_NOT_SUPPORTED;
		return errn;
	}*/


#if STRING_REPRESENTATION == STRING_REPRESENTATION_ASCII
	extraChar = 1; /* null terminator */
#endif /* STRING_REPRESENTATION_ASCII */

#if MEMORY_ALLOCATION == DYNAMIC_ALLOCATION
#endif /* DYNAMIC_ALLOCATION */


	currID = valueTable->len;

	/*if(currID == 32768) {
		/ * TODO overlap * /;
		return 0;
	}*/

	if( valueTable->size == currID ) {
#if MEMORY_ALLOCATION == STATIC_ALLOCATION
		/* no memory left to handle this string */
		errn = EXI_ERROR_STRINGVALUES_OUT_OF_MEMORY;
#endif/* STATIC_ALLOCATION */
#if MEMORY_ALLOCATION == DYNAMIC_ALLOCATION
		/* expand entries */
		if (valueTable->size == 0) {
			valueTable->size  = STRING_TABLE_INIT_VALUE_ENTRY_SIZE;
		} else {
			valueTable->size = ((valueTable->size) << 1); /* length * 2 */
		}

		/* old data */
		oldStrs = valueTable->strs;
		valueTable->strs = (exi_value_string_table_entry_t*) malloc(valueTable->size * sizeof(exi_value_string_table_entry_t));

		if(currID > 0) {
			/* copy old data */
			for(i=0; i<currID; i++) {
				valueTable->strs[i].localValueID =  oldStrs[i].localValueID;
				valueTable->strs[i].namespaceUriID = oldStrs[i].namespaceUriID;
				valueTable->strs[i].localNameID = oldStrs[i].localNameID;
				/*valueTable->valueStringTable->strs[i].qnameID =  oldStrs[i].qnameID; */
				valueTable->strs[i].str.size = oldStrs[i].str.size;
				valueTable->strs[i].str.len =  oldStrs[i].str.len;
				valueTable->strs[i].str.characters =  oldStrs[i].str.characters;
			}
			/*free old data */
			free(oldStrs);
		}
#endif /* DYNAMIC_ALLOCATION */
	}

	if (errn == 0) {
		valueTable->strs[currID].namespaceUriID = namespaceUriID;
		valueTable->strs[currID].localNameID = localNameID;
		/* valueTable->valueStringTable->strs[currLen].qnameID = qnameID; */
		exiGetNumberOfLocalStringValueEntries(valueTable, namespaceUriID, localNameID, &numberOfEntries);
		valueTable->strs[currID].localValueID = numberOfEntries;  /* valueTable->numberOfLocalStrings[qnameID]; */


#if MEMORY_ALLOCATION == STATIC_ALLOCATION
		/* make sure the str length fits into existing buffer */
		if ( (sv->len + extraChar) > valueTable->strs[currID].str.size ) {
			errn = EXI_ERROR_STRINGVALUES_OUT_OF_MEMORY;
		}
		/* set new length */
		valueTable->strs[currID].str.len = sv->len;
#endif/* STATIC_ALLOCATION */
#if MEMORY_ALLOCATION == DYNAMIC_ALLOCATION
		/* allocate codepoints memory */
		errn = exiAllocateDynamicStringMemory(&valueTable->strs[currID].str, (sv->len + extraChar));
		valueTable->strs[currID].str.len = sv->len;
#endif /* DYNAMIC_ALLOCATION */

		if(errn == 0) {
			/* copy codepoints or ASCII */
			if ( memcpy(valueTable->strs[currID].str.characters, sv->characters, (extraChar+sv->len)*sizeof(exi_string_character_t)) == NULL ) {
				errn = EXI_ERROR_STRINGVALUES_OUT_OF_MEMORY;
			}


			/* increment string count */
			valueTable->len++;

#if EXI_OPTION_VALUE_PARTITION_CAPACITY > 0
			if(valueTable->len > EXI_OPTION_VALUE_PARTITION_CAPACITY) {
				/* round robin --> reset "last/first" old entry string to length zero */
				i = 0;
				while(valueTable->strs[i].str.len == 0) {
					i++;
				}
				valueTable->strs[i].str.len = 0;
#if MEMORY_ALLOCATION == STATIC_ALLOCATION
				/* free string again */
				free(valueTable->strs[i].str.characters);
#endif /* DYNAMIC_ALLOCATION */
				valueTable->strs[i].str.characters = NULL;
			}
#endif /* EXI_OPTION_VALUE_PARTITION_CAPACITY > 0 */

		}
	}


#endif /* EXI_OPTION_VALUE_MAX_LENGTH != 0 */
#endif /* EXI_OPTION_VALUE_PARTITION_CAPACITY != 0 */


	return errn;
}



int exiGetNumberOfLocalStringValueEntries(exi_value_string_table_t* valueTable,
		size_t namespaceUriID, size_t localNameID, size_t* numberOfEntries) {
	/* TODO number of local entries and next id must not match, e.g, if string-table is restricted in number of entries */
	size_t i;
	int errn = 0;
	*numberOfEntries = 0;
	for(i=0; i<valueTable->len; i++) {
		if( valueTable->strs[i].namespaceUriID == namespaceUriID && valueTable->strs[i].localNameID == localNameID ) {
			(*numberOfEntries)++;
		}
	}

	return errn;
}

int exiGetNumberOfGlobalStringValueEntries(exi_value_string_table_t* valueTable, size_t* numberOfEntries) {
	int errn = 0;

#if EXI_OPTION_VALUE_PARTITION_CAPACITY > 0
	size_t i;
	*numberOfEntries = 0;
	for(i=0; i<valueTable->len; i++) {
		if (valueTable->strs[i].str.len == 0) {
			/* indicates removed string */
		} else {
			(*numberOfEntries)++;
		}
	}
#else
	*numberOfEntries = valueTable->len;
#endif /* EXI_OPTION_VALUE_PARTITION_CAPACITY > 0 */

	return errn;
}

int exiGetGlobalStringValue(exi_value_string_table_t* valueTable,
		size_t globalID, exi_string_t* sv) {
	int errn = 0;

#if EXI_OPTION_VALUE_PARTITION_CAPACITY > 0
	size_t i;
	size_t currentGlobals = 0;
	int found = 0;

	for(i=0; !found && i<valueTable->len; i++) {
		if (valueTable->strs[i].str.len == 0) {
			/* indicates removed string */
		} else {
			if(currentGlobals == globalID) {
				/* found string */
				*sv = valueTable->strs[i].str;
				found = 1;
			} else {
				currentGlobals++;
			}
		}
	}
#else
	if( valueTable->len > globalID) {
		*sv = valueTable->strs[globalID].str;
	} else {
		errn = EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;
	}
#endif /* EXI_OPTION_VALUE_PARTITION_CAPACITY > 0 */

	return errn;
}

int exiGetLocalStringValue(exi_value_string_table_t* valueTable,
		size_t namespaceUriID, size_t localNameID, size_t localValueID, exi_string_t* sv) {
	size_t i;
	int errn = EXI_ERROR_STRINGVALUES_OUT_OF_BOUND;

	/* walk over all entries. Note that if number of entries is restricted the local ID may be larger than the number of global entries */
	for(i=0; i<valueTable->len && errn != 0; i++) {
		if( valueTable->strs[i].namespaceUriID == namespaceUriID && valueTable->strs[i].localNameID == localNameID && valueTable->strs[i].localValueID == localValueID  ) {
			*sv = valueTable->strs[i].str;
			errn = 0;
		}
	}

	return errn;
}


#endif

